{
  "version": 3,
  "sources": ["browser-external:util", "browser-external:events", "../../chakra/chakra.js", "../../chakra/index.js", "dep:chakra"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"util\" has been externalized for browser compatibility. Cannot access \"util.${key}\" in client code.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"events\" has been externalized for browser compatibility. Cannot access \"events.${key}\" in client code.`)\n    }\n  }\n}))", "var util = require('util'),\n    EventEmitter = require('events').EventEmitter;\n\nvar CHANNEL_MSG_SENT = 'message:sent';\nvar CHANNEL_MSG_RECV = 'message:received';\n\n// Chakra\n// ======\n\n\n// Chakra's are a concept from yoga that represent centers of premeating energy on the\n// surface of the human body. This class provides a center for premeating messages as \n// an analogy for the Chakra.\n//\n// The `config` can be used to configure the Chakra and will be passed to the `configure`\n// function.\nfunction Chakra(config) {\n    // Maximum number of Channels this Chakra accepts. -1 means unlimited.\n    this.maxChannels = -1;\n\n    // List of Channels connected to the Chakra\n    this.channels = [];\n\n    if (config) {\n        this.configure(config);\n    }\n}\n\n// Configure the Chakra. Possible options:\n//\n// - maxChannels -  The maximum number of channels the Chakra accepts\n// - channels -     Channels that need to be connected to the Chakra\n//\n// returns the `Chakra` instance for a fluent interface.\nChakra.prototype.configure = function(config) {\n    if (config.maxChannels || config.max) {\n        this.maxChannels = config.maxChannels || config.max;\n    }\n\n    if (config.channels && Array.isArray(config.channels)) {\n        var connect = this.connect, channels = this.channels;\n\n        config.channels.forEach(function(channel) {\n            if (-1 === channels.indexOf(channel)) {\n                connect(channel);\n            }\n        });\n    }\n\n    return this;\n};\n\n// Connect a Channel to the Chakra. The `channel` will receive messages from the Chakra \n// and the Chakra will detect and transmit message from the `channel`.\n//\n// Returns the Chakra instance for a fluent interface.\nChakra.prototype.connect = function(channel) {\n    // Check if the number of channels will not go over the maximum\n    // and the channel is not in the list already\n    if((-1 >= this.maxChannels || this.channels.length < this.maxChannels) && -1 === this.channels.indexOf(channel)) {\n        var chakra = this;\n\n        // Listen for sent messages\n        channel.on(CHANNEL_MSG_SENT, function() {\n            // Catch the message arguments\n            var args = Array.prototype.slice.call(arguments, 0);\n\n            // `origin` should be the first parameter for the dispatch method\n            args.unshift(channel);\n\n            // Transmit the message\n            Chakra.prototype.transmit.apply(chakra, args);\n        });\n\n        // Add the channel to the list\n        this.channels.push(channel);\n    }\n\n    return this;\n};\n// Alias for the `connect` function\nChakra.prototype.addChannel = Chakra.prototype.connect;\n\n// Disconnect the `channel` from the Chakra. Returns the `Chakra` instance for a fluent interface.\nChakra.prototype.disconnect = function(channel) {\n    var index;\n    if (-1 !== (index = this.channels.indexOf(channel))) {\n        this.channels.splice(index, 1);\n    }\n\n    return this;\n};\n// Alias for the `disconnect` function.\nChakra.prototype.removeChannel = Chakra.prototype.disconnect;\n\n// Transmit a message to all connected channels. The Channel that the message\n// orignated from is skipped\nChakra.prototype.transmit = function(origin/*, args... */) {\n    // Gather arguments. Origin should be the first one\n    // and is only for internal use\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    // Pass the message to all channels except the origin\n    this.channels.forEach(function(channel) {\n        if (channel !== origin) {\n            Channel.prototype.receive.apply(channel, args);\n        }\n    });\n\n    return this;\n};\n\n// Channel\n// =======\n\n// Channels can receive message from one or multiple Chakras it is connected to and \n// send messages to the Chakra in order to have the message transmitted over other \n// Channels connected to the Chakra.\n// A `config` object can be used to configure the Channel and will be passed to the \n// `configure` function.\nfunction Channel(config) {\n    EventEmitter.call(this);\n\n    // Event emitter for message to separate message from the Channels events\n    this.messages = new Vortex();\n}\nutil.inherits(Channel, EventEmitter);\n\n// Listen for `message`s send on the Channel and handle them in the `callback`.\nChannel.prototype.listen = function(message, callback) {\n    this.messages.on(message, callback);\n};\n\n// Ignore a `message` on the Channel that was previously listened for and handled by the\n// `callback`\nChannel.prototype.ignore = function(message, callback) {\n    this.message.removeListener(message, callback);\n};\n\n// Receive a `message` on the Channel. This will trigger all listeners for the message.\n// Returns the `Channel` instance for a fluent interface.\nChannel.prototype.receive = function() {\n    // Convert arguments map to an array\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    // Emit an internal `CHANNEL_MSG_RECV` event\n    this.emit.apply(this, [CHANNEL_MSG_RECV].concat(args));\n\n    // Apply the args to the emit method of our Vortex\n    this.messages.emit.apply(this.messages, args);\n\n    return this;\n};\n// Alias for the `receive` function.\nChannel.prototype.deliver = Channel.prototype.receive;\n\n// Send a `message` over the Channel. This will be received by any Chakra this Channel\n// is connected to.\nChannel.prototype.send = function() {\n    // Convert arguments map to an array\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    // Add CHANNEL_MSG_SENT for internal processing\n    args.unshift(CHANNEL_MSG_SENT);\n\n    // Emit a `CHANNEL_MSG_SENT` event\n    this.emit.apply(this, args);\n\n    return this;\n};\n\n// Vortex\n// ======\n\n// Vortex is an extension of the standard EventEmitter and adds the option to set handlers\n// for any event triggered.\nfunction Vortex() {\n    // List of handlers called for any event\n    this._anyHandlers = [];\n\n    // Call our prototype to set up\n    EventEmitter.call(this);\n}\nutil.inherits(Vortex, EventEmitter);\n\n// Alter the emit method to include the registered onAny handlers\nVortex.prototype.emit = function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    // Call original emit\n    EventEmitter.prototype.emit.apply(this, args);\n\n    // Loop any handlers\n    var handlers = this._anyHandlers.slice();\n    for (var i = 0, l = handlers.length; i < l; i++) {\n        handlers[i].apply(this, args);\n    }\n    return true;\n};\n\n// Register a handler that is called on any event emitted from the Vortex\nVortex.prototype.onAny = function(handler) {\n    if ('function' !== typeof handler) {\n        throw new Error('handler must be a Function');\n    }\n\n    this._anyHandlers.push(handler);\n    return this;\n};\n\n// our awesome export products\nexports = module.exports = {\n    Chakra:  Chakra,\n    Channel: Channel,\n    Nadi:    Channel,\n    Vortex:  Vortex\n};\n", "// Just because I'm lazy\nexports = module.exports = require('./chakra');\n", "export default require(\"./node_modules/chakra/index.js\");"],
  "mappings": ";;;;;AAAA;AAAA;AAAA,WAAO,UAAU,OAAO,OAAO,IAAI,MAAM,CAAC,GAAG;AAAA,MAC3C,IAAI,GAAG,KAAK;AACV,YACE,QAAQ,gBACR,QAAQ,eACR,QAAQ,iBACR,QAAQ,UACR;AACA,kBAAQ,KAAK,sFAAsF,sBAAsB;AAAA,QAC3H;AAAA,MACF;AAAA,IACF,CAAC,CAAC;AAAA;AAAA;;;ACXF;AAAA;AAAA,WAAO,UAAU,OAAO,OAAO,IAAI,MAAM,CAAC,GAAG;AAAA,MAC3C,IAAI,GAAG,KAAK;AACV,YACE,QAAQ,gBACR,QAAQ,eACR,QAAQ,iBACR,QAAQ,UACR;AACA,kBAAQ,KAAK,0FAA0F,sBAAsB;AAAA,QAC/H;AAAA,MACF;AAAA,IACF,CAAC,CAAC;AAAA;AAAA;;;ACXF;AAAA;AAAA,QAAI,OAAO;AAAX,QACI,eAAe,iBAAkB;AAErC,QAAI,mBAAmB;AACvB,QAAI,mBAAmB;AAYvB,aAAS,OAAO,QAAQ;AAEpB,WAAK,cAAc;AAGnB,WAAK,WAAW,CAAC;AAEjB,UAAI,QAAQ;AACR,aAAK,UAAU,MAAM;AAAA,MACzB;AAAA,IACJ;AAQA,WAAO,UAAU,YAAY,SAAS,QAAQ;AAC1C,UAAI,OAAO,eAAe,OAAO,KAAK;AAClC,aAAK,cAAc,OAAO,eAAe,OAAO;AAAA,MACpD;AAEA,UAAI,OAAO,YAAY,MAAM,QAAQ,OAAO,QAAQ,GAAG;AACnD,YAAI,UAAU,KAAK,SAAS,WAAW,KAAK;AAE5C,eAAO,SAAS,QAAQ,SAAS,SAAS;AACtC,cAAI,OAAO,SAAS,QAAQ,OAAO,GAAG;AAClC,oBAAQ,OAAO;AAAA,UACnB;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX;AAMA,WAAO,UAAU,UAAU,SAAS,SAAS;AAGzC,WAAI,MAAM,KAAK,eAAe,KAAK,SAAS,SAAS,KAAK,gBAAgB,OAAO,KAAK,SAAS,QAAQ,OAAO,GAAG;AAC7G,YAAI,SAAS;AAGb,gBAAQ,GAAG,kBAAkB,WAAW;AAEpC,cAAI,OAAO,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AAGlD,eAAK,QAAQ,OAAO;AAGpB,iBAAO,UAAU,SAAS,MAAM,QAAQ,IAAI;AAAA,QAChD,CAAC;AAGD,aAAK,SAAS,KAAK,OAAO;AAAA,MAC9B;AAEA,aAAO;AAAA,IACX;AAEA,WAAO,UAAU,aAAa,OAAO,UAAU;AAG/C,WAAO,UAAU,aAAa,SAAS,SAAS;AAC5C,UAAI;AACJ,UAAI,QAAQ,QAAQ,KAAK,SAAS,QAAQ,OAAO,IAAI;AACjD,aAAK,SAAS,OAAO,OAAO,CAAC;AAAA,MACjC;AAEA,aAAO;AAAA,IACX;AAEA,WAAO,UAAU,gBAAgB,OAAO,UAAU;AAIlD,WAAO,UAAU,WAAW,SAAS,QAAsB;AAGvD,UAAI,OAAO,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AAGlD,WAAK,SAAS,QAAQ,SAAS,SAAS;AACpC,YAAI,YAAY,QAAQ;AACpB,kBAAQ,UAAU,QAAQ,MAAM,SAAS,IAAI;AAAA,QACjD;AAAA,MACJ,CAAC;AAED,aAAO;AAAA,IACX;AAUA,aAAS,QAAQ,QAAQ;AACrB,mBAAa,KAAK,IAAI;AAGtB,WAAK,WAAW,IAAI,OAAO;AAAA,IAC/B;AACA,SAAK,SAAS,SAAS,YAAY;AAGnC,YAAQ,UAAU,SAAS,SAAS,SAAS,UAAU;AACnD,WAAK,SAAS,GAAG,SAAS,QAAQ;AAAA,IACtC;AAIA,YAAQ,UAAU,SAAS,SAAS,SAAS,UAAU;AACnD,WAAK,QAAQ,eAAe,SAAS,QAAQ;AAAA,IACjD;AAIA,YAAQ,UAAU,UAAU,WAAW;AAEnC,UAAI,OAAO,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AAGlD,WAAK,KAAK,MAAM,MAAM,CAAC,gBAAgB,EAAE,OAAO,IAAI,CAAC;AAGrD,WAAK,SAAS,KAAK,MAAM,KAAK,UAAU,IAAI;AAE5C,aAAO;AAAA,IACX;AAEA,YAAQ,UAAU,UAAU,QAAQ,UAAU;AAI9C,YAAQ,UAAU,OAAO,WAAW;AAEhC,UAAI,OAAO,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AAGlD,WAAK,QAAQ,gBAAgB;AAG7B,WAAK,KAAK,MAAM,MAAM,IAAI;AAE1B,aAAO;AAAA,IACX;AAOA,aAAS,SAAS;AAEd,WAAK,eAAe,CAAC;AAGrB,mBAAa,KAAK,IAAI;AAAA,IAC1B;AACA,SAAK,SAAS,QAAQ,YAAY;AAGlC,WAAO,UAAU,OAAO,WAAW;AAC/B,UAAI,OAAO,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AAGlD,mBAAa,UAAU,KAAK,MAAM,MAAM,IAAI;AAG5C,UAAI,WAAW,KAAK,aAAa,MAAM;AACvC,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,IAAI,GAAG,KAAK;AAC7C,iBAAS,GAAG,MAAM,MAAM,IAAI;AAAA,MAChC;AACA,aAAO;AAAA,IACX;AAGA,WAAO,UAAU,QAAQ,SAAS,SAAS;AACvC,UAAI,eAAe,OAAO,SAAS;AAC/B,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAChD;AAEA,WAAK,aAAa,KAAK,OAAO;AAC9B,aAAO;AAAA,IACX;AAGA,cAAU,OAAO,UAAU;AAAA,MACvB;AAAA,MACA;AAAA,MACA,MAAS;AAAA,MACT;AAAA,IACJ;AAAA;AAAA;;;ACxNA,IAAAA,kBAAA;AAAA;AACA,cAAU,OAAO,UAAU;AAAA;AAAA;;;ACD3B,IAAO,iBAAQ;",
  "names": ["require_chakra"]
}
