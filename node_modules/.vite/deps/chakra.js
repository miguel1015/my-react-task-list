import {
  __commonJS
} from "./chunk-MB5FDF5C.js";

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/chakra/chakra.js
var require_chakra = __commonJS({
  "node_modules/chakra/chakra.js"(exports, module) {
    var util = require_util();
    var EventEmitter = require_events().EventEmitter;
    var CHANNEL_MSG_SENT = "message:sent";
    var CHANNEL_MSG_RECV = "message:received";
    function Chakra(config) {
      this.maxChannels = -1;
      this.channels = [];
      if (config) {
        this.configure(config);
      }
    }
    Chakra.prototype.configure = function(config) {
      if (config.maxChannels || config.max) {
        this.maxChannels = config.maxChannels || config.max;
      }
      if (config.channels && Array.isArray(config.channels)) {
        var connect = this.connect, channels = this.channels;
        config.channels.forEach(function(channel) {
          if (-1 === channels.indexOf(channel)) {
            connect(channel);
          }
        });
      }
      return this;
    };
    Chakra.prototype.connect = function(channel) {
      if ((-1 >= this.maxChannels || this.channels.length < this.maxChannels) && -1 === this.channels.indexOf(channel)) {
        var chakra = this;
        channel.on(CHANNEL_MSG_SENT, function() {
          var args = Array.prototype.slice.call(arguments, 0);
          args.unshift(channel);
          Chakra.prototype.transmit.apply(chakra, args);
        });
        this.channels.push(channel);
      }
      return this;
    };
    Chakra.prototype.addChannel = Chakra.prototype.connect;
    Chakra.prototype.disconnect = function(channel) {
      var index;
      if (-1 !== (index = this.channels.indexOf(channel))) {
        this.channels.splice(index, 1);
      }
      return this;
    };
    Chakra.prototype.removeChannel = Chakra.prototype.disconnect;
    Chakra.prototype.transmit = function(origin) {
      var args = Array.prototype.slice.call(arguments, 1);
      this.channels.forEach(function(channel) {
        if (channel !== origin) {
          Channel.prototype.receive.apply(channel, args);
        }
      });
      return this;
    };
    function Channel(config) {
      EventEmitter.call(this);
      this.messages = new Vortex();
    }
    util.inherits(Channel, EventEmitter);
    Channel.prototype.listen = function(message, callback) {
      this.messages.on(message, callback);
    };
    Channel.prototype.ignore = function(message, callback) {
      this.message.removeListener(message, callback);
    };
    Channel.prototype.receive = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      this.emit.apply(this, [CHANNEL_MSG_RECV].concat(args));
      this.messages.emit.apply(this.messages, args);
      return this;
    };
    Channel.prototype.deliver = Channel.prototype.receive;
    Channel.prototype.send = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift(CHANNEL_MSG_SENT);
      this.emit.apply(this, args);
      return this;
    };
    function Vortex() {
      this._anyHandlers = [];
      EventEmitter.call(this);
    }
    util.inherits(Vortex, EventEmitter);
    Vortex.prototype.emit = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      EventEmitter.prototype.emit.apply(this, args);
      var handlers = this._anyHandlers.slice();
      for (var i = 0, l = handlers.length; i < l; i++) {
        handlers[i].apply(this, args);
      }
      return true;
    };
    Vortex.prototype.onAny = function(handler) {
      if ("function" !== typeof handler) {
        throw new Error("handler must be a Function");
      }
      this._anyHandlers.push(handler);
      return this;
    };
    exports = module.exports = {
      Chakra,
      Channel,
      Nadi: Channel,
      Vortex
    };
  }
});

// node_modules/chakra/index.js
var require_chakra2 = __commonJS({
  "node_modules/chakra/index.js"(exports, module) {
    exports = module.exports = require_chakra();
  }
});

// dep:chakra
var chakra_default = require_chakra2();
export {
  chakra_default as default
};
//# sourceMappingURL=chakra.js.map
